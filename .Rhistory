# shuffle template index so are not compared in sequence, which makes progress bar more precise
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
# get correlation
xcrrs <- pbapply::pblapply(X = 1:nrow(spc.cmbs), cl = cl, FUN = function(j) {
XC_FUN(spc1 = spcs[[spc.cmbs[j, 1]]], spcs[[spc.cmbs[j, 2]]])
})
xcrrs <- xcrrs[order(ord.shuf)]
mx.xcrrs <- sapply(xcrrs, max)
#create a similarity matrix with the max xcorr
mat <- matrix(nrow = nrow(X), ncol = nrow(X))
mat[] <- 1
colnames(mat) <- rownames(mat) <- paste(X$sound.files, X$selec, sep = "-")
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
mat <- t(mat)
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
# View(mat)
mat2 <- xcorr(X, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
# View(mat2)
vegan::mantel(as.dist(mat), as.dist(mat2))
X <- playback_est
y <- sample(seq(1, 100, 10), 2)
X <- Phae.long.est[c(y[1]:(y[1] + 9), y[2]:(y[2] + 9)), ]
# bp checking
# if (is.null(bp)) stop("'bp' must be provided")
#
# if (bp[1] != "frange")
# {
#   if (!is.vector(bp)) stop("'bp' must be a numeric vector of length 2")
#   if (!length(bp) == 2) stop("'bp' must be a numeric vector of length 2")
#
#   #set freq limits
#   frq.lim <- bp
# } else  {
#   if (!any(names(X) == "bottom.freq") & !any(names(X) == "top.freq")) stop("'bp' = frange requires bottom.freq and top.freq columns in X")
#   if (any(is.na(c(X$bottom.freq, X$top.freq)))) stop("NAs found in bottom.freq and/or top.freq")
#   if (any(c(X$bottom.freq, X$top.freq) < 0)) stop("Negative values found in bottom.freq and/or top.freq")
#   if (any(X$top.freq - X$bottom.freq < 0)) stop("top.freq should be higher than low.f")      }
#
# X <- Phae.long.est
ind1 <- 1
ind2 <- 2
cl <- 3
wl <- 212
ovlp <- 90
wn <- "hanning"
cor.method <- "pearson"
# bp <- c(1, 10)
# get spectrogram for each selection
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(j) {
clp <- read_wave(X, j)
spc <- seewave::spectro(wave = clp, wl = wl, ovlp = ovlp, wn = wn, plot = FALSE, fftw = TRUE, norm = TRUE)
})
names(spcs) <- paste(X$sound.files, X$selec, sep = "-")
XC_FUN <- function(spc1, spc2){
#set freq limits as min and max of both spectros combined
frq.lim <- c(min(spc1$freq, spc2$freq), max(spc1$freq, spc2$freq))
# filter frequency
spc1$amp <- spc1$amp[which(spc1$freq >= frq.lim[1] & spc1$freq <= frq.lim[2]), ]
spc2$amp <- spc2$amp[which(spc2$freq >= frq.lim[1] & spc2$freq <= frq.lim[2]), ]
# define short and long envelope for sliding one (short) over the other (long)
if(ncol(spc1[[3]]) > ncol(spc2[[3]])) {
lg.spc <- spc1[[3]]
shrt.spc <- spc2[[3]]
} else {
lg.spc <- spc2[[3]]
shrt.spc <- spc1[[3]]
}
# get length of shortest minus 1 (1 if same length so it runs a single correlation)
shrt.lgth <- ncol(shrt.spc) - 1
# steps for sliding one signal over the other
stps <- ncol(lg.spc) - ncol(shrt.spc)
# set sequence of steps, if <= 1 then just 1 step
if (stps <= 1) stps <- 1 else stps <- 1:stps
# calculate correlations at each step
cors <- sapply(stps, function(x) {
warbleR::try_na(cor(c(lg.spc[, x:(x + shrt.lgth)]), c(shrt.spc), method = cor.method, use='pairwise.complete.obs'))
})
return(cors)
}
# generate all possible combinations of selections
spc.cmbs <- t(combn(names(spcs), 2))
# shuffle template index so are not compared in sequence, which makes progress bar more precise
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
# get correlation
xcrrs <- pbapply::pblapply(X = 1:nrow(spc.cmbs), cl = cl, FUN = function(j) {
XC_FUN(spc1 = spcs[[spc.cmbs[j, 1]]], spcs[[spc.cmbs[j, 2]]])
})
xcrrs <- xcrrs[order(ord.shuf)]
mx.xcrrs <- sapply(xcrrs, max)
#create a similarity matrix with the max xcorr
mat <- matrix(nrow = nrow(X), ncol = nrow(X))
mat[] <- 1
colnames(mat) <- rownames(mat) <- paste(X$sound.files, X$selec, sep = "-")
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
mat <- t(mat)
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
# View(mat)
mat2 <- xcorr(X, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
# View(mat2)
vegan::mantel(as.dist(mat), as.dist(mat2))
X <- playback_est
y <- sample(seq(1, 100, 10), 2)
X <- Phae.long.est[c(y[1]:(y[1] + 9), y[2]:(y[2] + 9)), ]
# bp checking
# if (is.null(bp)) stop("'bp' must be provided")
#
# if (bp[1] != "frange")
# {
#   if (!is.vector(bp)) stop("'bp' must be a numeric vector of length 2")
#   if (!length(bp) == 2) stop("'bp' must be a numeric vector of length 2")
#
#   #set freq limits
#   frq.lim <- bp
# } else  {
#   if (!any(names(X) == "bottom.freq") & !any(names(X) == "top.freq")) stop("'bp' = frange requires bottom.freq and top.freq columns in X")
#   if (any(is.na(c(X$bottom.freq, X$top.freq)))) stop("NAs found in bottom.freq and/or top.freq")
#   if (any(c(X$bottom.freq, X$top.freq) < 0)) stop("Negative values found in bottom.freq and/or top.freq")
#   if (any(X$top.freq - X$bottom.freq < 0)) stop("top.freq should be higher than low.f")      }
#
# X <- Phae.long.est
ind1 <- 1
ind2 <- 2
cl <- 3
wl <- 212
ovlp <- 90
wn <- "hanning"
cor.method <- "pearson"
# bp <- c(1, 10)
# get spectrogram for each selection
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(j) {
clp <- read_wave(X, j)
spc <- seewave::spectro(wave = clp, wl = wl, ovlp = ovlp, wn = wn, plot = FALSE, fftw = TRUE, norm = TRUE)
})
names(spcs) <- paste(X$sound.files, X$selec, sep = "-")
XC_FUN <- function(spc1, spc2){
#set freq limits as min and max of both spectros combined
frq.lim <- c(min(spc1$freq, spc2$freq), max(spc1$freq, spc2$freq))
# filter frequency
spc1$amp <- spc1$amp[which(spc1$freq >= frq.lim[1] & spc1$freq <= frq.lim[2]), ]
spc2$amp <- spc2$amp[which(spc2$freq >= frq.lim[1] & spc2$freq <= frq.lim[2]), ]
# define short and long envelope for sliding one (short) over the other (long)
if(ncol(spc1[[3]]) > ncol(spc2[[3]])) {
lg.spc <- spc1[[3]]
shrt.spc <- spc2[[3]]
} else {
lg.spc <- spc2[[3]]
shrt.spc <- spc1[[3]]
}
# get length of shortest minus 1 (1 if same length so it runs a single correlation)
shrt.lgth <- ncol(shrt.spc) - 1
# steps for sliding one signal over the other
stps <- ncol(lg.spc) - ncol(shrt.spc)
# set sequence of steps, if <= 1 then just 1 step
if (stps <= 1) stps <- 1 else stps <- 1:stps
# calculate correlations at each step
cors <- sapply(stps, function(x) {
warbleR::try_na(cor(c(lg.spc[, x:(x + shrt.lgth)]), c(shrt.spc), method = cor.method, use='pairwise.complete.obs'))
})
return(cors)
}
# generate all possible combinations of selections
spc.cmbs <- t(combn(names(spcs), 2))
# shuffle template index so are not compared in sequence, which makes progress bar more precise
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
# get correlation
xcrrs <- pbapply::pblapply(X = 1:nrow(spc.cmbs), cl = cl, FUN = function(j) {
XC_FUN(spc1 = spcs[[spc.cmbs[j, 1]]], spcs[[spc.cmbs[j, 2]]])
})
xcrrs <- xcrrs[order(ord.shuf)]
mx.xcrrs <- sapply(xcrrs, max)
#create a similarity matrix with the max xcorr
mat <- matrix(nrow = nrow(X), ncol = nrow(X))
mat[] <- 1
colnames(mat) <- rownames(mat) <- paste(X$sound.files, X$selec, sep = "-")
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
mat <- t(mat)
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
# View(mat)
mat2 <- xcorr(X, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
# View(mat2)
vegan::mantel(as.dist(mat), as.dist(mat2))
X <- playback_est
y <- sample(seq(1, 100, 10), 2)
X <- Phae.long.est[c(y[1]:(y[1] + 9), y[2]:(y[2] + 9)), ]
X <- Phae.long.est[1:50, ]
# bp checking
# if (is.null(bp)) stop("'bp' must be provided")
#
# if (bp[1] != "frange")
# {
#   if (!is.vector(bp)) stop("'bp' must be a numeric vector of length 2")
#   if (!length(bp) == 2) stop("'bp' must be a numeric vector of length 2")
#
#   #set freq limits
#   frq.lim <- bp
# } else  {
#   if (!any(names(X) == "bottom.freq") & !any(names(X) == "top.freq")) stop("'bp' = frange requires bottom.freq and top.freq columns in X")
#   if (any(is.na(c(X$bottom.freq, X$top.freq)))) stop("NAs found in bottom.freq and/or top.freq")
#   if (any(c(X$bottom.freq, X$top.freq) < 0)) stop("Negative values found in bottom.freq and/or top.freq")
#   if (any(X$top.freq - X$bottom.freq < 0)) stop("top.freq should be higher than low.f")      }
#
# X <- Phae.long.est
ind1 <- 1
ind2 <- 2
cl <- 3
wl <- 212
ovlp <- 90
wn <- "hanning"
cor.method <- "pearson"
# bp <- c(1, 10)
# get spectrogram for each selection
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(j) {
clp <- read_wave(X, j)
spc <- seewave::spectro(wave = clp, wl = wl, ovlp = ovlp, wn = wn, plot = FALSE, fftw = TRUE, norm = TRUE)
})
names(spcs) <- paste(X$sound.files, X$selec, sep = "-")
XC_FUN <- function(spc1, spc2){
#set freq limits as min and max of both spectros combined
frq.lim <- c(min(spc1$freq, spc2$freq), max(spc1$freq, spc2$freq))
# filter frequency
spc1$amp <- spc1$amp[which(spc1$freq >= frq.lim[1] & spc1$freq <= frq.lim[2]), ]
spc2$amp <- spc2$amp[which(spc2$freq >= frq.lim[1] & spc2$freq <= frq.lim[2]), ]
# define short and long envelope for sliding one (short) over the other (long)
if(ncol(spc1[[3]]) > ncol(spc2[[3]])) {
lg.spc <- spc1[[3]]
shrt.spc <- spc2[[3]]
} else {
lg.spc <- spc2[[3]]
shrt.spc <- spc1[[3]]
}
# get length of shortest minus 1 (1 if same length so it runs a single correlation)
shrt.lgth <- ncol(shrt.spc) - 1
# steps for sliding one signal over the other
stps <- ncol(lg.spc) - ncol(shrt.spc)
# set sequence of steps, if <= 1 then just 1 step
if (stps <= 1) stps <- 1 else stps <- 1:stps
# calculate correlations at each step
cors <- sapply(stps, function(x) {
warbleR::try_na(cor(c(lg.spc[, x:(x + shrt.lgth)]), c(shrt.spc), method = cor.method, use='pairwise.complete.obs'))
})
return(cors)
}
# generate all possible combinations of selections
spc.cmbs <- t(combn(names(spcs), 2))
# shuffle template index so are not compared in sequence, which makes progress bar more precise
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
# get correlation
xcrrs <- pbapply::pblapply(X = 1:nrow(spc.cmbs), cl = cl, FUN = function(j) {
XC_FUN(spc1 = spcs[[spc.cmbs[j, 1]]], spcs[[spc.cmbs[j, 2]]])
})
xcrrs <- xcrrs[order(ord.shuf)]
mx.xcrrs <- sapply(xcrrs, max)
#create a similarity matrix with the max xcorr
mat <- matrix(nrow = nrow(X), ncol = nrow(X))
mat[] <- 1
colnames(mat) <- rownames(mat) <- paste(X$sound.files, X$selec, sep = "-")
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
mat <- t(mat)
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
# View(mat)
mat2 <- xcorr(X, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
# View(mat2)
vegan::mantel(as.dist(mat), as.dist(mat2))
X <- playback_est
y <- sample(seq(1, 100, 10), 2)
X <- Phae.long.est[c(y[1]:(y[1] + 9), y[2]:(y[2] + 9)), ]
X <- Phae.long.est#[1:50, ]
# bp checking
# if (is.null(bp)) stop("'bp' must be provided")
#
# if (bp[1] != "frange")
# {
#   if (!is.vector(bp)) stop("'bp' must be a numeric vector of length 2")
#   if (!length(bp) == 2) stop("'bp' must be a numeric vector of length 2")
#
#   #set freq limits
#   frq.lim <- bp
# } else  {
#   if (!any(names(X) == "bottom.freq") & !any(names(X) == "top.freq")) stop("'bp' = frange requires bottom.freq and top.freq columns in X")
#   if (any(is.na(c(X$bottom.freq, X$top.freq)))) stop("NAs found in bottom.freq and/or top.freq")
#   if (any(c(X$bottom.freq, X$top.freq) < 0)) stop("Negative values found in bottom.freq and/or top.freq")
#   if (any(X$top.freq - X$bottom.freq < 0)) stop("top.freq should be higher than low.f")      }
#
# X <- Phae.long.est
ind1 <- 1
ind2 <- 2
cl <- 3
wl <- 212
ovlp <- 90
wn <- "hanning"
cor.method <- "pearson"
# bp <- c(1, 10)
# get spectrogram for each selection
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(j) {
clp <- read_wave(X, j)
spc <- seewave::spectro(wave = clp, wl = wl, ovlp = ovlp, wn = wn, plot = FALSE, fftw = TRUE, norm = TRUE)
})
names(spcs) <- paste(X$sound.files, X$selec, sep = "-")
XC_FUN <- function(spc1, spc2){
#set freq limits as min and max of both spectros combined
frq.lim <- c(min(spc1$freq, spc2$freq), max(spc1$freq, spc2$freq))
# filter frequency
spc1$amp <- spc1$amp[which(spc1$freq >= frq.lim[1] & spc1$freq <= frq.lim[2]), ]
spc2$amp <- spc2$amp[which(spc2$freq >= frq.lim[1] & spc2$freq <= frq.lim[2]), ]
# define short and long envelope for sliding one (short) over the other (long)
if(ncol(spc1[[3]]) > ncol(spc2[[3]])) {
lg.spc <- spc1[[3]]
shrt.spc <- spc2[[3]]
} else {
lg.spc <- spc2[[3]]
shrt.spc <- spc1[[3]]
}
# get length of shortest minus 1 (1 if same length so it runs a single correlation)
shrt.lgth <- ncol(shrt.spc) - 1
# steps for sliding one signal over the other
stps <- ncol(lg.spc) - ncol(shrt.spc)
# set sequence of steps, if <= 1 then just 1 step
if (stps <= 1) stps <- 1 else stps <- 1:stps
# calculate correlations at each step
cors <- sapply(stps, function(x) {
warbleR::try_na(cor(c(lg.spc[, x:(x + shrt.lgth)]), c(shrt.spc), method = cor.method, use='pairwise.complete.obs'))
})
return(cors)
}
# generate all possible combinations of selections
spc.cmbs <- t(combn(names(spcs), 2))
# shuffle template index so are not compared in sequence, which makes progress bar more precise
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
# get correlation
xcrrs <- pbapply::pblapply(X = 1:nrow(spc.cmbs), cl = cl, FUN = function(j) {
XC_FUN(spc1 = spcs[[spc.cmbs[j, 1]]], spcs[[spc.cmbs[j, 2]]])
})
xcrrs <- xcrrs[order(ord.shuf)]
mx.xcrrs <- sapply(xcrrs, max)
#create a similarity matrix with the max xcorr
mat <- matrix(nrow = nrow(X), ncol = nrow(X))
mat[] <- 1
colnames(mat) <- rownames(mat) <- paste(X$sound.files, X$selec, sep = "-")
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
mat <- t(mat)
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
# View(mat)
mat2 <- xcorr(X, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
# View(mat2)
vegan::mantel(as.dist(mat), as.dist(mat2))
sp <- specan(X, bp = c(1, 10))
sp.dst <- dist(sp[, -c(1, 2)])
vegan::mantel(as.dist(mat), sp.dst)
vegan::mantel(as.dist(mat2), sp.dst)
vegan::mantel(as.dist(mat), as.dist(mat2))
vegan::mantel(as.dist(1 - mat2), sp.dst)
vegan::mantel(as.dist(1 - mat), sp.dst)
vegan::mantel(as.dist(1 - mat2), sp.dst)
vegan::mantel(as.dist(1 - mat), as.dist(1- mat2))
dtw.dst <- df_DTW(X, bp = c(1, 10))
vegan::mantel(as.dist(1 - mat2), as.dist(dtw.dst))
vegan::mantel(as.dist(1 - mat), as.dist(dtw.dst))
bi_mats <- function(X, labels) {
# create empty matrix to store memebership matrix
mat <- matrix(nrow = ncol(X), ncol = ncol(X))
# add labels to row and col names
rownames(mat) <- colnames(mat) <- labels
# add 0 if same lek and 1 if else
out <- lapply(1:(length(labels) - 1), function(i){
sapply((i + 1):length(labels), function(j)
if (labels[i] == labels[j]) 0 else 1)
})
# add to mat
mat[lower.tri(mat)] <- unlist(out)
# retunr as distance matrix
return(as.dist(mat))
}
bi_mats(mat, colnames(mat))
bmt <- bi_mats(mat, colnames(mat))
vegan::mantel(as.dist(1 - mat), as.dist(bmt))
bmt
bmt <- bi_mats(mat, X$lek.song.type)
vegan::mantel(as.dist(1 - mat), as.dist(bmt))
vegan::mantel(as.dist(1 - mat2), as.dist(bmt))
X
attr(X, "check.results")
attr(X, "check.results")$sample.rate
all.equal(attr(X, "check.results")$sample.rate)
attr(X, "check.results")$sample.rate
all.equal(attr(X, "check.results")$sample.rate)
length(unique(attr(X, "check.results")$sample.rate))
length(unique(attr(X, "check.results")$sample.rate)) > 1
stop("all wave objects in the extended selection table must have the same sampling rate (they can be homogenized using resample_est())")
spcs
spcs[[1]]
spcs[[1]]$freq
sapply(spcs, function(x) length(x$freq))
sapply(spcs, function(x) length(x$freq))
length(unique(sapply(spcs, function(x) length(x$freq)))) > 1
length(unique(sapply(spcs, function(x) length(x$freq))))
pb = TRUE
# get spectrogram for each selection
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(j) {
clp <- read_wave(X, j)
spc <- seewave::spectro(wave = clp, wl = wl, ovlp = ovlp, wn = wn, plot = FALSE, fftw = TRUE, norm = TRUE)
})
# check sampling rate is the same for all selections if not a selection table
if (!is_extended_selection_table(X) & length(unique(sapply(spcs, function(x) length(x$freq)))) > 1) stop("sampling rate must be the same for all selections")
# add selection name
names(spcs) <- paste(X$sound.files, X$selec, sep = "-")
# create function to calculate correlation between 2 spectrograms
XC_FUN <- function(spc1, spc2){
#set freq limits as min and max of both spectros combined
frq.lim <- c(min(spc1$freq, spc2$freq), max(spc1$freq, spc2$freq))
# filter frequency
spc1$amp <- spc1$amp[which(spc1$freq >= frq.lim[1] & spc1$freq <= frq.lim[2]), ]
spc2$amp <- spc2$amp[which(spc2$freq >= frq.lim[1] & spc2$freq <= frq.lim[2]), ]
# define short and long envelope for sliding one (short) over the other (long)
if(ncol(spc1[[3]]) > ncol(spc2[[3]])) {
lg.spc <- spc1[[3]]
shrt.spc <- spc2[[3]]
} else {
lg.spc <- spc2[[3]]
shrt.spc <- spc1[[3]]
}
# get length of shortest minus 1 (1 if same length so it runs a single correlation)
shrt.lgth <- ncol(shrt.spc) - 1
# steps for sliding one signal over the other
stps <- ncol(lg.spc) - ncol(shrt.spc)
# set sequence of steps, if <= 1 then just 1 step
if (stps <= 1) stps <- 1 else stps <- 1:stps
# calculate correlations at each step
cors <- sapply(stps, function(x) {
warbleR::try_na(cor(c(lg.spc[, x:(x + shrt.lgth)]), c(shrt.spc), method = cor.method, use='pairwise.complete.obs'))
})
return(cors)
}
# generate all possible combinations of selections
spc.cmbs <- t(combn(names(spcs), 2))
# shuffle template index so are not compared in sequence, which makes progress bar more precise when some selections are much longer than others
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
#run cross-correlation
if (pb) write(file = "", x ="running cross-correlation (step 2 of 2):")
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
# get correlation
xcrrs <- pbapply::pblapply(X = 1:nrow(spc.cmbs), cl = cl, FUN = function(j) {
XC_FUN(spc1 = spcs[[spc.cmbs[j, 1]]], spcs[[spc.cmbs[j, 2]]])
})
parallel = 3
# order as originally
xcrrs <- xcrrs[order(ord.shuf)]
# extract maximum correlation
mx.xcrrs <- sapply(xcrrs, max)
#create a similarity matrix with the max xcorr
mat <- matrix(nrow = nrow(X), ncol = nrow(X))
mat[] <- 1
colnames(mat) <- rownames(mat) <- paste(X$sound.files, X$selec, sep = "-")
# add max correlations
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
mat <- t(mat)
mat[lower.tri(mat, diag=FALSE)] <- mx.xcrrs
names(xcrrs)
# generate all possible combinations of selections, keep one with the orignal order of rows to create cor.table output
spc.cmbs.org <- spc.cmbs <- t(combn(names(spcs), 2))
# shuffle template index so are not compared in sequence, which makes progress bar more precise when some selections are much longer than others
ord.shuf <- sample(1:nrow(spc.cmbs))
# sampling rate must be the same
spc.cmbs <- spc.cmbs[ord.shuf, ]
xcorr(X[1:2,],cor.mat = F, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
aa <-xcorr(X[1:2,],cor.mat = F, ovlp = ovlp, bp = frq.lim, pb = F, dens = 1, parallel = cl)
aa$correlation.data
head(aa$correlation.data)
x
paste(spc.cmbs.org[, x], collapse = "/")
paste(spc.cmbs.org[x, ], collapse = "/")
head(aa$correlation.data)
cor.lst <- lapply(1:nrow(spc.cmbs.org), function(x) data.frame(dyad = paste(spc.cmbs.org[x, ], collapse = "/"), sound.file1 = spc.cmbs.org[x, 1], sound.file2 = spc.cmbs.org[x, 2], score = xcrrs[[x]]))
cor.lst
head(aa$correlation.data)
lentgth(xcrrs[[x]])
length(xcrrs[[x]])
spcs[[1]]$time
seq(0, length(xcrrs[[x]]), by = spcs[[1]]$time[2])
seq(0, length(xcrrs[[x]]) * spcs[[1]]$time[2], by = spcs[[1]]$time[2])
cor.lst <- lapply(1:nrow(spc.cmbs.org), function(x)
data.frame(
dyad = paste(spc.cmbs.org[x, ], collapse = "/"),
sound.file1 = spc.cmbs.org[x, 1],
sound.file2 = spc.cmbs.org[x, 2],
time = seq(0, length(xcrrs[[x]]) * spcs[[1]]$time[2], by = spcs[[1]]$time[2]),
score = xcrrs[[x]]))
cor.lst <- lapply(1:nrow(spc.cmbs.org), function(x)
data.frame(
dyad = paste(spc.cmbs.org[x, ], collapse = "/"),
sound.file1 = spc.cmbs.org[x, 1],
sound.file2 = spc.cmbs.org[x, 2],
time = seq(0, length(xcrrs[[x]]) * spcs[[1]]$time[2], length.out = length(xcrrs[[x]])),
score = xcrrs[[x]]))
cor.lst
# put together in a single dataframe
cor.table <- do.call(rbind, cor.lst)
cor.table
head(cor.table)
source('~/Dropbox/warbleR/R/xcorr2.R')
