View(snra)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2)
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.1, noise.ref = 'adjacent', type = 2, eq.dur = T)
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T)
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T)
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
snra
snra$signal.to.noise.ratio
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra
snra$signal.to.noise.ratio
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
# remove noise selections
pe <- playback_est[playback_est$signal.type != "ambient", ]
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra
snra$signal.to.noise.ratio
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
snr
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
snra
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
#tests
{
signal_to_noise_ratio(X = playback_est, mar = 0.05, noise.ref = 'custom')
# remove noise selections
pe <- playback_est[playback_est$signal.type != "ambient", ]
# using margin for noise of 0.05 and adjacent noise reference
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
snra
snra$signal.to.noise.ratio
print("all is good!")
}
signal_to_noise_ratio(X = playback_est, mar = 0.05, noise.ref = 'custom')
# remove noise selections
pe <- playback_est[playback_est$signal.type != "ambient", ]
snra <- signal_to_noise_ratio(X = pe, mar = 0.05, noise.ref = 'adjacent')
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
snra
snra$signal.to.noise.ratio
snra <- signal_to_noise_ratio(X = pe, mar = 0.5, noise.ref = 'adjacent', type = 2, eq.dur = T, bp = "freq.range")
snra
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
X
FUN <- "signal_to_noise_ratio"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
# remove noise selections
pe <- playback_est[playback_est$signal.type != "ambient", ]
X = pe
mar = 0.01
y = 1
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, header = TRUE)
# read sample rate
f <- r$sample.rate
# set margin to half of signal duration
if (eq.dur) mar <- (X$end[y] - X$start[y]) else if(all(argus != "mar")) stop("'mar' must be provided when 'eq.dur = FALSE'")
mar
#reset time coordinates of signals if higher than duration
enn <- X$end[y] + mar
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
r <- warbleR::read_wave(X = X, index = y, from = stn, to = enn)
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
r
# read sample rate
f <- r$sample.rate
#reset time coordinates of signals if higher than duration
enn <- X$end[y] + mar
enn
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# read sample rate
f <- r$sample.rate
#reset time coordinates of signals if higher than duration
enn <- X$end[y] + mar
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
r <- warbleR::read_wave(X = X, index = y)
# read signal and margin
tail.wv <- warbleR::read_wave(X = X, index = y, from = X$end[y], to = enn)
# read signal
signal <- warbleR::read_wave(X = X, index = y)
# get RMS for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
# get RMS for background noise
tail.env <- seewave::env(tail.wv, f = f, envt = "abs", plot = FALSE)
# signal RMS
sig_RMS <- seewave::rms(sig.env)
# signal RMS
sig_RMS <- seewave::rms(sig.env)
# get reference ambient noise RMS
tail_RMS <- seewave::rms(tail.env)
# Calculate signal-to-noise ratio
if (type == 1)
str <- sig_RMS / tail_RMS
if (type == 2)
str <- (sig_RMS - tail_RMS) / tail_RMS
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_tail_ratio.R')
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
signal_to_noise_ratio(X = playback_est, mar = 0.05, noise.ref = 'custom')
signal_to_tail_ratio(X = playback_est, mar = 0.05, noise.ref = 'custom')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_tail_ratio.R')
sig2noise(pe, mar = 0.05)
pe
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_tail_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_tail_ratio.R')
sig_RMS
bg_RMS
bg_RMS <- 100
20 * log10(sig_RMS / bg_RMS)
20*log10((sig_RMS) / bg_RMS)
20*log10((sig_RMS - bg_RMS) / bg_RMS)
(sig_RMS - bg_RMS) / bg_RMS
-20*log10((sig_RMS - bg_RMS) / bg_RMS)
bg_RMS <- 70
-20*log10((sig_RMS - bg_RMS) / bg_RMS)
playback_est
playback_est <- resample_est(playback_est, samp.rate = 44.1)
sig2noise(playback_est, mar = 0.1)
save(playback_est, file="./data/playback_est.rda", version = 2)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_tail_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
FUN <- "signal_to_noise_ratio"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
tail_to_signal_ratio(X = playback_est, mar = 0.05, noise.ref = 'custom')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
FUN <- "signal_to_noise_ratio"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
tail_to_signal_ratio(X = playback_est, mar = 0.05, noise.ref = 'custom')
# remove noise selections
pe <- playback_est[playback_est$signal.type != "ambient", ]
tail_to_signal_ratio(X = pe, mar = 0.05, noise.ref = 'custom')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
tail_to_signal_ratio(X = pe, mar = 0.05, noise.ref = 'custom')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
tail_to_signal_ratio(X = pe, mar = 0.05, noise.ref = 'custom')
tail_to_signal_ratio(X = pe, mar = 0.05)
tail_to_signal_ratio(X = pe, mar = 0.05)
tail_to_signal_ratio(X = playback_est, mar = 0.05, type = 2)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
tail_to_signal_ratio(X = playback_est, mar = 0.05, type = 2)
X
X = pe
mar = 0.01
tail_to_signal_ratio(X = pe, mar = 0.01)
type = 2
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/signal_to_noise_ratio.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
tail_to_signal_ratio(X = playback_est, mar = 0.01, type = 2)
source('~/.active-rstudio-document', echo=TRUE)
tail_to_signal_ratio(X = pe, mar = 0.01)
# remove noise selections
pe <- playback_est[playback_est$signal.type != "ambient", ]
print("type 1")
tail_to_signal_ratio(X = pe, mar = 0.01)
tail_to_signal_ratio(X = pe, mar = 0.01, bp = "freq.range")
tail_to_signal_ratio(X = pe, mar = 0.01, bp = NULL)
tail_to_signal_ratio(X = playback_est, mar = 0.01, type = 2)
y = 2
X
X = pe
mar = 0.01
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# read sample rate
f <- r$sample.rate
#reset time coordinates of signals if higher than duration
enn <- X$end[y] + mar
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
tail.wv <- warbleR::read_wave(X = X, index = y, from = X$end[y], to = enn)
# read signal
if (type == 1)
signal <- warbleR::read_wave(X = X, index = y)
# read background noise right before the signal
if (type == 2)
signal <- warbleR::read_wave(X = X, index = y, from = X$start[y] - mar, to = X$start[y])
signal <- warbleR::read_wave(X = X, index = y, from = X$start[y] - mar, to = X$start[y])
signal
tail.wv
tail.wv
# add band-pass frequency filter
if (!is.null(bp)) {
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
tail.wv <- seewave::ffilter(tail.wv, f = tail.wv@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
}
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
wl = 512
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
signal
bp
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
wl = 100
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
tail.wv <- seewave::ffilter(tail.wv, f = tail.wv@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
y
# get RMS for signal
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
# get RMS for background noise
tail.env <- seewave::env(tail.wv, f = f, envt = "abs", plot = FALSE)
# signal RMS
sig_RMS <- seewave::rms(sig.env)
# get reference ambient noise RMS
tail_RMS <- seewave::rms(tail.env)
str <- sig_RMS / tail_RMS
str
20*log10(str)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
tail_to_signal_ratio(X = playback_est, mar = 0.01, type = 2)
X
mar = 0.01
tail_to_signal_ratio(X = playback_est, mar = 0.01, type = 2, wl = 100)
tail_to_signal_ratio(X = playback_est, mar = 0.01, type = 2, bp = NULL)
y = 2
# Read sound files to get sample rate and length
r <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, header = TRUE)
# read sample rate
f <- r$sample.rate
#reset time coordinates of signals if higher than duration
enn <- X$end[y] + mar
if (enn > r$samples/f) enn <- r$samples/f
# read signal and margin
tail.wv <- warbleR::read_wave(X = X, index = y, from = X$end[y], to = enn)
signal <- warbleR::read_wave(X = X, index = y, from = X$start[y] - mar, to = X$start[y])
bp
bp = "freq.range"
!is.null(bp)
# filter to bottom and top freq range
if (bp == "freq.range")
bp <- c(X$bottom.freq[y], X$top.freq[y])
signal <- seewave::ffilter(signal, f = signal@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
tail.wv <- seewave::ffilter(tail.wv, f = tail.wv@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl,
output = "Wave")
tail.wv
signal
# get RMS for signal (or noise if type 2)
sig.env <- seewave::env(signal, f = signal@samp.rate, envt = "abs", plot = FALSE)
sig.env
# get RMS for background noise
tail.env <- seewave::env(tail.wv, f = f, envt = "abs", plot = FALSE)
# signal (or noise) RMS
sig_RMS <- seewave::rms(sig.env)
# get reference ambient noise RMS
tail_RMS <- seewave::rms(tail.env)
tail_RMS
sig_RMS
# Calculate tail.to.signal ratio
if (type == 1)
str <- sig_RMS / tail_RMS
if (type == 2)
str <- (sig_RMS - tail_RMS) / tail_RMS
str <- (sig_RMS - tail_RMS) / tail_RMS
str
20*log10(str)
# Calculate tail.to.signal ratio
str <- sig_RMS / tail_RMS
<- sig_RMS / tail_RMS
str
20*log10(str)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/tail_to_signal_ratio.R')
tail_to_signal_ratio(X = pe, mar = 0.01, bp = NULL)
tail_to_signal_ratio(X = playback_est, mar = 0.01, type = 2)
source('~/.active-rstudio-document', echo=TRUE)
#open function in rstudio
open.fun <- function(fun) system(paste("rstudio", file.path("./R", paste0(fun, ".R"))))
# run default arguments in a function
run.def.args <- function(fun = NULL){
#list functions in package
rfiles <- list.files(pattern = ".R", path = "./R", full.names = T)
# select target function file
funfile <- rfiles[gsub(".R", "", basename(rfiles)) == fun]
x <- readLines(funfile, warn = F)
st <- grep('@usage', x, fixed = T)
en <- grep('@param', x, fixed = T)[1]
x <- paste(x[st:(en-1)], collapse = " ")
x <- gsub("usage|\\@|\\#\\'", "", x)
b <- gregexpr(pattern ='\\(|\\)',x)[1][[1]]
x <- substr(x, start = b[1] + 1, stop = b[length(b)] - 1)
spltx <- strsplit(x, "\\,")[[1]]
sl <- vector()
y = 1
while(y <= length(spltx))
{
w <- spltx[y]
z <- 1
if(grepl('\\(', spltx[y]))
{z  <- 0
while(!grepl('\\)', w))
{
z <- z+ 1
w <- paste(w, ",", spltx[y + z], collapse = "")
}
z <- z + 1
}
y = y + z
sl[length(sl) + 1] <- w
}
sl <- sl[sl != "X"]
return(sl)
}
# run it like this:
# for(i in run.def.args("dfts")) try(eval(parse(text = i)), silent = T)
# remove sound files and or image files
rm.sf <- function() unlink(list.files(path = tempdir(), pattern = "\\.wav$", ignore.case = T, full.names = TRUE))
rm.sf.img <- function(mp3 = TRUE) {if(mp3)
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.mp3$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE)) else
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE))}
rm.img <- function() unlink(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$|\\.pdf$", ignore.case = T, full.names = TRUE))
#open latest image
last.img <- function() system(paste("eog", list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)))]
))
#open pdf
last.pdf <- function() system(paste("xdg-open", list.files(path = tempdir(), pattern = "\\.pdf$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.pdf", ignore.case = T, full.names = TRUE)))]
))
#find text in functions
find.text <- function(pattern, fun.only = FALSE, path = "./R", ignore.case = T)
{
rfiles <- list.files(pattern = "\\.R$|\\.Rmd$", path = path, full.names = T, all.files = T)
#check where a word is found in each function an return the name of function where it was found and the time
res <- NULL
w <- 1
for(f in rfiles){
x <- readLines(f)
y <- grep(pattern, x, fixed = T, value = T, ignore.case = ignore.case)
if(length(y)>0 & !fun.only) {
print(gsub(pattern = "\\.R", "", (basename(f))))
for(i in y) print(i)
}
if(length(y)>0 & fun.only) res[w] <- gsub(pattern = "\\.R", "", (basename(f)))
# options(nwarnings = 0)
w = w + 1
}
if(fun.only)
{res <- res[!is.na(res)]
return(res)}
}
#replace text
repl.text <- function(pattern, repl, path = "./R", ignore.case = T){
rfiles <- list.files(pattern = "\\.R$|\\.Rmd", path = path, full.names = T, all.files = T)
for(f in rfiles){
#find and replace
x <- readLines(f)
y <- gsub(pattern, repl, x, fixed = T, ignore.case = ignore.case)
cat(y, file=f, sep="\n")
#reread
x <- readLines(f)
w <- grep(repl, x, fixed = T, value = T, ignore.case = T)
if(length(w)>0) {
print(f)
for(i in w) print(i)
}
}
}
#find functions with specific arguments
find.arg <- function(arg1, arg2 = NULL){
rfiles <- list.files(pattern = "\\.R$", path = "./R", full.names = T, all.files = T)
funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#big data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
# run all fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "./R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
run.all()
# check spelling
spch <- devtools::spell_check(".")
spch$word[grep("tail", spch$found)]
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
setwd(".")
#built site
pkgdown::build_site()
system("git add .")
system('git commit -m  "version 1.0.2"')
system("git push origin master")
