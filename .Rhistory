labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
np <- noise_profile(X = playback_est, hop.size = 2, ,noise.ref =  "custom")
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
### using raw files
data(list = c("Phae.long1", "Phae.long2", "Phae.long3", "Phae.long4"))
td <- tempdir()
# save sound files to temporary folder
writeWave(Phae.long1, file.path(td, "Phae.long1.wav"))
writeWave(Phae.long2, file.path(td, "Phae.long2.wav"))
writeWave(Phae.long3, file.path(td, "Phae.long3.wav"))
writeWave(Phae.long4, file.path(td, "Phae.long4.wav"))
np <- noise_profile(wl =  1000, mar = 0.01,noise.ref =  "custom", path = td)
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
np <- noise_profile(wl =  1000, mar = 0.01,noise.ref =  "custom", path = td, norm = TRUE)
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/noise_profile.R')
stn
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
y =1
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
stn
X$start[y]
X$start
X
#' Note that lower values will increase time resolution, which is more important for amplitude ratio calculations.
#' @param PSD Logical to control whether the Probability Mass Function (the probability distribution of frequencies). See \code{\link[seewave]{meanspec}}. Default is \code{FALSE}.
#' @param norm Logical to control whether amplitude values are normalized (divided by the maximum) so the highest value is 1. See \code{\link[seewave]{meanspec}}. Default is \code{FALSE}.
#' @return A list containing the the frequency spectra for each sound file or wave object (if 'X' is supplied).
#' @export
#' @name noise_profile
#' @details The function uses \code{\link[seewave]{meanspec}} internally.
#' @examples
#' {
#' # load example data
data("playback_est")
#'
#' # custom noise reference (default)
#' noise_profile(X = playback_est, mar = 0.01, pb = FALSE)
#'
#' # remove noise selections
#' pe <- playback_est[playback_est$signal.type != "ambient", ]
#'
#'  noise_profile(X = pe, mar = 0.01, pb = FALSE, noise.ref = "adjacent")
#' }
#'
#' @author Marcelo Araya-Salas (\email{marceloa27@@gmail.com})
#' @seealso \code{\link{excess_attenuation}}
#' @references {
#' Araya-Salas, M. (2020). baRulho: baRulho: quantifying habitat-induced degradation of (animal) acoustic signals in R. R package version 1.0.2.
#'
#' }
#last modification on nov-01-2019 (MAS)
noise_profile <- function(X = NULL, files = NULL, mar = NULL, noise.ref = "adjacent", parallel = 1, pb = TRUE, path = NULL,
bp = NULL, hop.size = 1, wl = NULL, PSD = FALSE, norm = FALSE){
# get call argument names
argus <- names(as.list(base::match.call()))
# set pb options
on.exit(pbapply::pboptions(type = .Options$pboptions$type), add = TRUE)
# if X was supplied
if (!is.null(X)){
# set files to null
files <- NULL
# is extended sel tab
if (!warbleR::is_extended_selection_table(X))
stop("'X' must be and extended selection table")
# check signal.type column
if (is.null(X$signal.type)) stop("'X' must containe a 'signal.type' column")
# invert selections so gaps become selections instead if noise.ref != ambient
if (noise.ref == "custom" & !any(X$signal.type == "ambient")) stop("'noise.ref = custom' but no 'ambient' label found in 'signal.type' column ") else # keep only 'ambient' selections
X <- X[X$signal.type == "ambient", ]
if (noise.ref == "adjacent" & is.null(mar)) stop("'mar' must be supplied when 'noise.ref == 'adjacent''")
} else # if  no  files and no X get files in path
if (is.null(files)){
#check path to working directory
if (is.null(path)) path <- getwd() else
if (!dir.exists(path)) stop("'path' provided does not exist") else
path <- normalizePath(path)
files <- list.files(path = path, pattern = "\\.wav$", ignore.case = TRUE)
if (length(files) == 0) stop("No files found in working directory (alternatively supply 'X')")
}
# check files
if (!is.null(files)){
if (any(!file.exists(file.path(path, files)))) stop(paste(paste(files[!file.exists(files)], collapse = "/"), "was (were) not found"))
# created selection table from sound files
X <- warbleR::selection_table(whole.recs = TRUE, pb = FALSE, path = path)
# filter sound files in files
X <- X[X$sound.files %in% files, ]
# add signal column
X$signal.type <- "ambient"
# set noise.ref to ambient so the whole sound file is measured
noise.ref <- "custom"
}
# if parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
# hopsize
if (!is.numeric(hop.size) | hop.size < 0) stop("'parallel' must be a positive number")
# adjust wl based on hope.size
if (is.null(wl))
wl <- round(attr(X, "check.results")$sample.rate[1] * hop.size, 0)
# set pb options
pbapply::pboptions(type = ifelse(as.logical(pb), "timer", "none"))
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
# calculate STR
noise.profiles <- pbapply::pblapply(1:nrow(X), cl = cl, function(y){
# extract  complete sound file for custom or files in folder
if (noise.ref == "custom")
noise.wv <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, path = path)
if (noise.ref == "adjacent")
{
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
if (stn < 0)
stn <- 0
# read ambient noise
noise.wv <- warbleR::read_wave(X = X, index = y, from = stn, to = X$start[y])
}
# add band-pass frequency filter
if (!is.null(bp))
noise.wv <- seewave::ffilter(noise.wv, f = noise.wv@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl, output = "Wave")
# mean spec
mspc <- meanspec(wave = noise.wv, f = noise.wv@samp.rate, plot = FALSE, wl = wl, ovlp = 0, PSD = PSD, PMF = FALSE, norm = norm)
# name columns
colnames(mspc) <- c("freq", "amp")
# add sound file name
mspc <- data.frame(sound.files = X$sound.files[y], selec= X$selec[y], mspc)
return(mspc)
})
# get numbers of rows
rws <- sapply(noise.profiles, nrow)
# make all the same length if noise.ref is adjacent
if (length(unique(rws)) > 1 & noise.ref == "adjacent"){
# gt freq range of minimum
fr.range <- range(noise.profiles[[which.min(rws)]]$frequency)
# interpolate so all have the same number of frequency bins
noise.profiles <- lapply(noise.profiles, function(Y){
# interpolate
Yappr <- approx(x = Y$freq,
y = Y$amp,
xout = seq(from = fr.range[1], to = fr.range[2],
length.out = min(rws)),
method = "linear")
Ydf <- data.frame(sound.files = Y$sound.files[1], selec = Y$selec[1], freq = Yappr$x, amp = Yappr$y)
return(Ydf)
})
}
# put together in 1 data frame
noise.profile <- do.call(rbind, noise.profiles)
# get mean by sound file
noise.profile <- aggregate(formula = amp ~ sound.files + freq, data = noise.profile, FUN = mean)
return(noise.profile)
}
data("playback_est")
# custom noise reference (default)
noise_profile(X = playback_est, mar = 0.01, pb = FALSE)
pe <- playback_est[playback_est$signal.type != "ambient", ]
noise_profile(X = pe, mar = 0.01, pb = FALSE, noise.ref = "adjacent")
pe <- playback_est[playback_est$signal.type != "ambient", ]
X = pe
mar = 0.01
pb = FALSE
noise.ref = "adjacent"
# if X was supplied
if (!is.null(X)){
# set files to null
files <- NULL
# is extended sel tab
if (!warbleR::is_extended_selection_table(X))
stop("'X' must be and extended selection table")
# check signal.type column
if (is.null(X$signal.type)) stop("'X' must containe a 'signal.type' column")
# invert selections so gaps become selections instead if noise.ref != ambient
if (noise.ref == "custom" & !any(X$signal.type == "ambient")) stop("'noise.ref = custom' but no 'ambient' label found in 'signal.type' column ") else # keep only 'ambient' selections
X <- X[X$signal.type == "ambient", ]
if (noise.ref == "adjacent" & is.null(mar)) stop("'mar' must be supplied when 'noise.ref == 'adjacent''")
} else # if  no  files and no X get files in path
if (is.null(files)){
#check path to working directory
if (is.null(path)) path <- getwd() else
if (!dir.exists(path)) stop("'path' provided does not exist") else
path <- normalizePath(path)
files <- list.files(path = path, pattern = "\\.wav$", ignore.case = TRUE)
if (length(files) == 0) stop("No files found in working directory (alternatively supply 'X')")
}
# check files
if (!is.null(files)){
if (any(!file.exists(file.path(path, files)))) stop(paste(paste(files[!file.exists(files)], collapse = "/"), "was (were) not found"))
# created selection table from sound files
X <- warbleR::selection_table(whole.recs = TRUE, pb = FALSE, path = path)
# filter sound files in files
X <- X[X$sound.files %in% files, ]
# add signal column
X$signal.type <- "ambient"
# set noise.ref to ambient so the whole sound file is measured
noise.ref <- "custom"
}
# if parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
# hopsize
if (!is.numeric(hop.size) | hop.size < 0) stop("'parallel' must be a positive number")
# adjust wl based on hope.size
if (is.null(wl))
wl <- round(attr(X, "check.results")$sample.rate[1] * hop.size, 0)
# set pb options
pbapply::pboptions(type = ifelse(as.logical(pb), "timer", "none"))
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
# calculate STR
noise.profiles <- pbapply::pblapply(1:nrow(X), cl = cl, function(y){
# extract  complete sound file for custom or files in folder
if (noise.ref == "custom")
noise.wv <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, path = path)
if (noise.ref == "adjacent")
{
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
if (stn < 0)
stn <- 0
# read ambient noise
noise.wv <- warbleR::read_wave(X = X, index = y, from = stn, to = X$start[y])
}
# add band-pass frequency filter
if (!is.null(bp))
noise.wv <- seewave::ffilter(noise.wv, f = noise.wv@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl, output = "Wave")
# mean spec
mspc <- meanspec(wave = noise.wv, f = noise.wv@samp.rate, plot = FALSE, wl = wl, ovlp = 0, PSD = PSD, PMF = FALSE, norm = norm)
# name columns
colnames(mspc) <- c("freq", "amp")
# add sound file name
mspc <- data.frame(sound.files = X$sound.files[y], selec= X$selec[y], mspc)
return(mspc)
})
X
X = pe
#' @return A list containing the the frequency spectra for each sound file or wave object (if 'X' is supplied).
#' @export
#' @name noise_profile
#' @details The function uses \code{\link[seewave]{meanspec}} internally.
#' @examples
#' {
#' # load example data
#' data("playback_est")
#'
#' # custom noise reference
noise_profile(X = playback_est, mar = 0.01, pb = FALSE, noise.ref = "custom")
#'
#' # remove noise selections
#' pe <- playback_est[playback_est$signal.type != "ambient", ]
#'
#'  noise_profile(X = pe, mar = 0.01, pb = FALSE, noise.ref = "adjacent")
#' }
#'
#' @author Marcelo Araya-Salas (\email{marceloa27@@gmail.com})
#' @seealso \code{\link{excess_attenuation}}
#' @references {
#' Araya-Salas, M. (2020). baRulho: baRulho: quantifying habitat-induced degradation of (animal) acoustic signals in R. R package version 1.0.2.
#'
#' }
#last modification on nov-01-2019 (MAS)
noise_profile <- function(X = NULL, files = NULL, mar = NULL, noise.ref = "adjacent", parallel = 1, pb = TRUE, path = NULL,
bp = NULL, hop.size = 1, wl = NULL, PSD = FALSE, norm = FALSE){
# get call argument names
argus <- names(as.list(base::match.call()))
# set pb options
on.exit(pbapply::pboptions(type = .Options$pboptions$type), add = TRUE)
# if X was supplied
if (!is.null(X)){
# set files to null
files <- NULL
# is extended sel tab
if (!warbleR::is_extended_selection_table(X))
stop("'X' must be and extended selection table")
# check signal.type column
if (is.null(X$signal.type)) stop("'X' must containe a 'signal.type' column")
# invert selections so gaps become selections instead if noise.ref != ambient
if (noise.ref == "custom" & !any(X$signal.type == "ambient")) stop("'noise.ref = custom' but no 'ambient' label found in 'signal.type' column ") else # keep only 'ambient' selections
X <- X[X$signal.type == "ambient", ]
if (noise.ref == "adjacent" & is.null(mar)) stop("'mar' must be supplied when 'noise.ref == 'adjacent''")
} else # if  no  files and no X get files in path
if (is.null(files)){
#check path to working directory
if (is.null(path)) path <- getwd() else
if (!dir.exists(path)) stop("'path' provided does not exist") else
path <- normalizePath(path)
files <- list.files(path = path, pattern = "\\.wav$", ignore.case = TRUE)
if (length(files) == 0) stop("No files found in working directory (alternatively supply 'X')")
}
# check files
if (!is.null(files)){
if (any(!file.exists(file.path(path, files)))) stop(paste(paste(files[!file.exists(files)], collapse = "/"), "was (were) not found"))
# created selection table from sound files
X <- warbleR::selection_table(whole.recs = TRUE, pb = FALSE, path = path)
# filter sound files in files
X <- X[X$sound.files %in% files, ]
# add signal column
X$signal.type <- "ambient"
# set noise.ref to ambient so the whole sound file is measured
noise.ref <- "custom"
}
# if parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
# hopsize
if (!is.numeric(hop.size) | hop.size < 0) stop("'parallel' must be a positive number")
# adjust wl based on hope.size
if (is.null(wl))
wl <- round(attr(X, "check.results")$sample.rate[1] * hop.size, 0)
# set pb options
pbapply::pboptions(type = ifelse(as.logical(pb), "timer", "none"))
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
# calculate STR
noise.profiles <- pbapply::pblapply(1:nrow(X), cl = cl, function(y){
# extract  complete sound file for custom or files in folder
if (noise.ref == "custom")
noise.wv <- warbleR::read_wave(X = X, index = y, from = 0, to = Inf, path = path)
if (noise.ref == "adjacent")
{
#reset time coordinates of signals if lower than 0 o higher than duration
stn <- X$start[y] - mar
if (stn < 0)
stn <- 0
# read ambient noise
noise.wv <- warbleR::read_wave(X = X, index = y, from = stn, to = X$start[y])
}
# add band-pass frequency filter
if (!is.null(bp))
noise.wv <- seewave::ffilter(noise.wv, f = noise.wv@samp.rate, from = bp[1] * 1000, ovlp = 0,
to = bp[2] * 1000, bandpass = TRUE, wl = wl, output = "Wave")
# mean spec
mspc <- meanspec(wave = noise.wv, f = noise.wv@samp.rate, plot = FALSE, wl = wl, ovlp = 0, PSD = PSD, PMF = FALSE, norm = norm)
# name columns
colnames(mspc) <- c("freq", "amp")
# add sound file name
mspc <- data.frame(sound.files = X$sound.files[y], selec= X$selec[y], mspc)
return(mspc)
})
# get numbers of rows
rws <- sapply(noise.profiles, nrow)
# make all the same length if noise.ref is adjacent
if (length(unique(rws)) > 1 & noise.ref == "adjacent"){
# gt freq range of minimum
fr.range <- range(noise.profiles[[which.min(rws)]]$frequency)
# interpolate so all have the same number of frequency bins
noise.profiles <- lapply(noise.profiles, function(Y){
# interpolate
Yappr <- approx(x = Y$freq,
y = Y$amp,
xout = seq(from = fr.range[1], to = fr.range[2],
length.out = min(rws)),
method = "linear")
Ydf <- data.frame(sound.files = Y$sound.files[1], selec = Y$selec[1], freq = Yappr$x, amp = Yappr$y)
return(Ydf)
})
}
# put together in 1 data frame
noise.profile <- do.call(rbind, noise.profiles)
# get mean by sound file
noise.profile <- aggregate(formula = amp ~ sound.files + freq, data = noise.profile, FUN = mean)
return(noise.profile)
}
noise_profile(X = playback_est, mar = 0.01, pb = FALSE, noise.ref = "custom")
X = pe
# if X was supplied
if (!is.null(X)){
# set files to null
files <- NULL
# is extended sel tab
if (!warbleR::is_extended_selection_table(X))
stop("'X' must be and extended selection table")
# check signal.type column
if (is.null(X$signal.type)) stop("'X' must containe a 'signal.type' column")
# invert selections so gaps become selections instead if noise.ref != ambient
if (noise.ref == "custom" & !any(X$signal.type == "ambient")) stop("'noise.ref = custom' but no 'ambient' label found in 'signal.type' column ") else # keep only 'ambient' selections
X <- X[X$signal.type == "ambient", ]
if (noise.ref == "adjacent" & is.null(mar)) stop("'mar' must be supplied when 'noise.ref == 'adjacent''")
} else # if  no  files and no X get files in path
if (is.null(files)){
#check path to working directory
if (is.null(path)) path <- getwd() else
if (!dir.exists(path)) stop("'path' provided does not exist") else
path <- normalizePath(path)
files <- list.files(path = path, pattern = "\\.wav$", ignore.case = TRUE)
if (length(files) == 0) stop("No files found in working directory (alternatively supply 'X')")
}
X
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/noise_profile.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/noise_profile.R')
noise_profile(X = pe, mar = 0.01, pb = FALSE, noise.ref = "adjacent")
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/noise_profile.R')
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/noise_profile.R')
FUN <- "noise_profile"
#run function
source(file.path("./R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
np <- noise_profile(X = playback_est, hop.size = 2, mar = 0.01)
source('~/sda5/Dropbox/R_package_testing/baRulho/baRulho/R/noise_profile.R')
np <- noise_profile(X = playback_est, hop.size = 2, mar = 0.01)
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
np <- noise_profile(X = playback_est, hop.size = 2, ,noise.ref =  "custom")
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
### using raw files
data(list = c("Phae.long1", "Phae.long2", "Phae.long3", "Phae.long4"))
td <- tempdir()
# save sound files to temporary folder
writeWave(Phae.long1, file.path(td, "Phae.long1.wav"))
writeWave(Phae.long2, file.path(td, "Phae.long2.wav"))
writeWave(Phae.long3, file.path(td, "Phae.long3.wav"))
writeWave(Phae.long4, file.path(td, "Phae.long4.wav"))
np <- noise_profile(wl =  1000, mar = 0.01,noise.ref =  "custom", path = td)
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude") +
coord_flip() +
theme_classic()
np <- noise_profile(X = playback_est, hop.size = 2, mar = 0.01, dB = "max0")
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude (dBA)") +
coord_flip() +
theme_classic()
np <- noise_profile(X = playback_est, hop.size = 2, mar = 0.01, dB = "A")
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude (dBA)") +
coord_flip() +
theme_classic()
np <- noise_profile(X = playback_est, hop.size = 2, mar = 0.01, dB = "B")
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude (dBA)") +
coord_flip() +
theme_classic()
np <- noise_profile(X = playback_est, hop.size = 2, mar = 0.01, dB = "C")
ggplot(np, aes(y = amp, x = freq, col = sound.files)) +
geom_line() +
scale_color_manual(values = viridis::viridis(4)) +
labs(x = "Frequency (kHz)", y = "Amplitude (dBA)") +
coord_flip() +
theme_classic()
#delete NAMESPACE file
unlink("./NAMESPACE")
#run document twice
devtools::document(".")
devtools::document(".")
#check with devtools
devtools::check(".", document = TRUE, run_dont_test = FALSE)
setwd(".")
#built site
pkgdown::build_site()
#built site
pkgdown::build_site()
# to set a new computer
## 1. install git
# 2. generate ssh key https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent#adding-your-ssh-key-to-the-ssh-agent
# 3. add key to github account https://help.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account
#sent to github
system("git add .")
system('git commit -m  "noise_profile() added"')
system("git push origin master")
