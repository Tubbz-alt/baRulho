repl <- 'an extended selection'
repl.text(pattern = pattern, repl = repl, path = path)
pattern <-  'warbleR_options'
find.text(pattern = pattern, fun.only = F, ignore.case = T, path = path)
pattern <-  'master'
find.text(pattern = pattern, fun.only = F, ignore.case = T, path = path)
pattern <-  'master playback'
find.text(pattern = pattern, fun.only = F, ignore.case = T, path = path)
repl <- 'reference playback'
repl.text(pattern = pattern, repl = repl, path = path)
sig2noise()
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/baRulho", document = TRUE, run_dont_test = FALSE)
pattern <-  'a R package to evaluate habitat-induced degradation'
find.text(pattern = pattern, fun.only = F, ignore.case = T, path = path)
repl <- 'a R package to quantify habitat-induced degradation'
repl.text(pattern = pattern, repl = repl, path = path)
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/baRulho", document = TRUE, run_dont_test = FALSE)
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/baRulho", document = TRUE, run_dont_test = FALSE)
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/baRulho", document = TRUE, run_dont_test = FALSE)
# check spelling
devtools::spell_check("/home/m/Dropbox/baRulho")
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/baRulho", document = TRUE, run_dont_test = FALSE)
setwd("~/Dropbox/baRulho")
#built site
pkgdown::build_site(pkg = "~/Dropbox/baRulho")
#sent to github
system("git add .")
system('git commit -m  "reviewed by Erin Grabarczyk"')
rm(list = ls())
#
# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))
x <- c("RColorBrewer", "devtools", "seewave", "warbleR", "monitoR", "pkgdown", "ape", "baRulho")
aa <- lapply(x, function(y) {
if(!y %in% installed.packages()[,"Package"])  {if(!y %in% c("warbleR", "Rraven", "baRluho", "NatureSounds")) install.packages(y) else devtools::install_github(paste0("maRce10/", y))
}
try(require(y, character.only = T), silent = T)
}
)
#open function in rstudio
open.fun <- function(fun) system(paste("rstudio", file.path("~/Dropbox/baRulho/R", paste0(fun, ".R"))))
# run default arguments in a function
run.def.args <- function(fun = NULL){
#list functions in package
rfiles <- list.files(pattern = ".R", path = "/home/m/Dropbox/baRulho/R", full.names = T)
# select target function file
funfile <- rfiles[gsub(".R", "", basename(rfiles)) == fun]
x <- readLines(funfile, warn = F)
st <- grep('@usage', x, fixed = T)
en <- grep('@param', x, fixed = T)[1]
x <- paste(x[st:(en-1)], collapse = " ")
x <- gsub("usage|\\@|\\#\\'", "", x)
b <- gregexpr(pattern ='\\(|\\)',x)[1][[1]]
x <- substr(x, start = b[1] + 1, stop = b[length(b)] - 1)
spltx <- strsplit(x, "\\,")[[1]]
sl <- vector()
y = 1
while(y <= length(spltx))
{
w <- spltx[y]
z <- 1
if(grepl('\\(', spltx[y]))
{z  <- 0
while(!grepl('\\)', w))
{
z <- z+ 1
w <- paste(w, ",", spltx[y + z], collapse = "")
}
z <- z + 1
}
y = y + z
sl[length(sl) + 1] <- w
}
sl <- sl[sl != "X"]
return(sl)
}
# run it like this:
# for(i in run.def.args("dfts")) try(eval(parse(text = i)), silent = T)
# remove sound files and or image files
rm.sf <- function() unlink(list.files(path = tempdir(), pattern = "\\.wav$", ignore.case = T, full.names = TRUE))
rm.sf.img <- function(mp3 = TRUE) {if(mp3)
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.mp3$|\\.tiff$|\\.jpeg$|\\.png$", ignore.case = T, full.names = TRUE)) else
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.tiff$|\\.jpeg$|\\.png$", ignore.case = T, full.names = TRUE))}
rm.img <- function() unlink(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.png$|\\.pdf$", ignore.case = T, full.names = TRUE))
#open latest image
last.img <- function() system(paste("eog", list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$", ignore.case = T, full.names = TRUE)))]
))
#open pdf
last.pdf <- function() system(paste("xdg-open", list.files(path = tempdir(), pattern = "\\.pdf$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.pdf", ignore.case = T, full.names = TRUE)))]
))
#find text in functions
find.text <- function(pattern, fun.only = FALSE, path = "/home/m/Dropbox/baRulho/R", ignore.case = T)
{
rfiles <- list.files(pattern = "\\.R$|\\.Rmd$", path = path, full.names = T, all.files = T)
#check where a word is found in each function an return the name of function where it was found and the time
res <- NULL
w <- 1
for(f in rfiles){
x <- readLines(f)
y <- grep(pattern, x, fixed = T, value = T, ignore.case = ignore.case)
if(length(y)>0 & !fun.only) {
print(gsub(pattern = "\\.R", "", (basename(f))))
for(i in y) print(i)
}
if(length(y)>0 & fun.only) res[w] <- gsub(pattern = "\\.R", "", (basename(f)))
# options(nwarnings = 0)
w = w + 1
}
if(fun.only)
{res <- res[!is.na(res)]
return(res)}
}
#replace text
repl.text <- function(pattern, repl, path = "/home/m/Dropbox/baRulho/R", ignore.case = T){
rfiles <- list.files(pattern = "\\.R$|\\.Rmd", path = path, full.names = T, all.files = T)
for(f in rfiles){
#find and replace
x <- readLines(f)
y <- gsub(pattern, repl, x, fixed = T, ignore.case = ignore.case)
cat(y, file=f, sep="\n")
#reread
x <- readLines(f)
w <- grep(repl, x, fixed = T, value = T, ignore.case = T)
if(length(w)>0) {
print(f)
for(i in w) print(i)
}
}
}
#find functions with specific arguments
find.arg <- function(arg1, arg2 = NULL){
rfiles <- list.files(pattern = "\\.R$", path = "/home/m/Dropbox/baRulho/R", full.names = T, all.files = T)
funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#bid data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
# run all fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "/home/m/Dropbox/baRulho/R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
run.all()
FUN <- "spectrum_correlation"
#run function
source(file.path("~/Dropbox/baRulho/R", paste0(FUN, ".R")))
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
X = playback_est
#open in rstudio
open.fun(fun = FUN)
# If parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
# If method is not numeric
if (!is.character(cor.method)) stop("'cor.method' must be a character vector of length 1")
if (!any(cor.method %in%  c("pearson", "kendall", "spearman"))) stop("'method' must be either  'pearson', 'kendall' or 'spearman'")
# check signal.id column
if (is.null(X$signal.id)) stop("'X' must containe a 'signal.id' column")
#check output
if (!any(output %in% c("est", "data.frame"))) stop("'output' must be either 'est' or 'data.frame'")
# set pb options
pbapply::pboptions(type = ifelse(as.logical(pb), "timer", "none"))
# set clusters for windows OS
if (Sys.info()[1] == "Windows" & parallel > 1)
cl <- parallel::makePSOCKcluster(getOption("cl.cores", parallel)) else cl <- parallel
if (pb) write(file = "", x = "calculating frequency spectrums (step 1 of 2):")
# calculate all envelopes apply function
envs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(y)   {
clp <- warbleR::read_wave(X = X, index = y)
env(wave = clp, f = clp@samp.rate, ssmooth = ssmooth, plot = FALSE, msmooth = msmooth)[, 1]
})
y =
1
clp <- warbleR::read_wave(X = X, index = y)
a <- meanspec(wave = clp, f = clp@samp.rate, plot = FALSE)[, 1]
str(a)
a <- meanspec(wave = clp, f = clp@samp.rate, plot = FALSE)[, 2]
a
plot(a, type = "l")
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(y)   {
clp <- warbleR::read_wave(X = X, index = y)
meanspec(wave = clp, f = clp@samp.rate, plot = FALSE)[, 2]
})
spcs
# calculate all spectra apply function
spcs <- pbapply::pblapply(X = 1:nrow(X), cl = cl, FUN = function(y)   {
clp <- warbleR::read_wave(X = X, index = y)
meanspec(wave = clp, f = clp@samp.rate, plot = FALSE)
})
# add sound file selec column and names to envelopes (weird column name so it does not overwrite user columns)
X$TEMP....y <- names(spcs) <- paste(X$sound.files, X$selec, sep = "-")
X$TEMP....z <- sapply(1:nrow(X), function(x, meth = method){
# extract for single signal and order by distance
Y <- as.data.frame(X[X$signal.id == X$signal.id[X$TEMP....y == X$TEMP....y[x]], , drop = FALSE])
Y <- Y[order(Y$distance), ]
# method 1 compare to closest distance to source
if (meth == 1) z <- Y$TEMP....y[which.min(Y$distance)] else # if method 2
# if not the first row then the previous row
if (Y$TEMP....y[1] != X$TEMP....y[x]) z <- X$TEMP....y[x - 1] else # else the first row
z <- Y$TEMP....y[1]
return(z)
})
X$TEMP....z
x = 1
y = X$TEMP....y[x]
z = X$TEMP....z[x]
y
z
z = X$TEMP....z[2]
z
y = X$TEMP....y[2]
y
# extract envelope for signal and model
sgnl.spctr <- spcs[[which(names(spcs) == y)]]
mdl.spctr <- spcs[[which(names(spcs) == z)]]
X
sgnl.spctr
sgnl.spctr$x
sgnl.spctr[, 1]
names(spcs)
y
z
frng <- c(min(X$bottom.freq[X$TEMP....y %in% c(y, z)]), max(X$top.freq[X$TEMP....y %in% c(y, z)]))
frng
frng
sgnl.spctr[, 1] > frng[1]
sgnl.spctr[, 1] > frng[1] & sgnl.spctr[, 1] < frng[2]
sgnl.spctr <- sgnl.spctr[sgnl.spctr[, 1] > frng[1] & sgnl.spctr[, 1] < frng[2], 2]
sgnl.spctr
mdl.spctr <- mdl.spctr[mdl.spctr[, 1] > frng[1] & mdl.spctr[, 1] < frng[2], 2]
mdl.spctr
length(mdl.spctr) > length(sgnl.spctr)
# get correlation assuming they have same length
cor.spctr <- cor(sgnl.spctr, mdl.spctr, method = cor.method)
cor.spctr
spctr_cor_FUN <- function(y, z){
# if names are the same return NA
if (y == z) out <- NA else {
# extract envelope for signal and model
sgnl.spctr <- spcs[[which(names(spcs) == y)]]
mdl.spctr <- spcs[[which(names(spcs) == z)]]
### filter to freq range of signals and remove freq column
# get range as lowest bottom and highest top
frng <- c(min(X$bottom.freq[X$TEMP....y %in% c(y, z)]), max(X$top.freq[X$TEMP....y %in% c(y, z)]))
sgnl.spctr <- sgnl.spctr[sgnl.spctr[, 1] > frng[1] & sgnl.spctr[, 1] < frng[2], 2]
mdl.spctr <- mdl.spctr[mdl.spctr[, 1] > frng[1] & mdl.spctr[, 1] < frng[2], 2]
# get correlation assuming they have same length
cor.spctr <- cor(sgnl.spctr, mdl.spctr, method = cor.method)
}
return(cor.spctr)
}
X$spctr.cor <- pbapply::pbsapply(X = 1:nrow(X), cl = cl, FUN = function(x) {
spctr_cor_FUN(y = X$TEMP....y[x], z = X$TEMP....z[x])
})
X$spctr.cor
# remove temporal columns
X$TEMP....y <- X$TEMP....z <- NULL
source('~/Dropbox/baRulho/R/spectrum_correlation.R')
a <- spectrum_correlation(X = playback_est)
a
FUN <- "blur_ratio"
#run function
source(file.path("~/Dropbox/baRulho/R", paste0(FUN, ".R")))
#open in rstudio
##open.fun(fun = FUN)
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
{
print("output est")
a <- blur_ratio(X = playback_est)
print("output data frame")
blur_ratio(X = playback_est, output = "data.frame")
print("using method 1 and msmooth")
b2 <- envelope_correlation(X = playback_est, msmooth = c(700, 50))
# similarity between envelope_correlation with different ssmooth
cor(b2$env.cor, a$env.cor, use = "pairwise.complete.obs")
print("using method 2")
a <- envelope_correlation(X = playback_est, method = 2)
print("using method 2 and ssmooth = 200")
b <- envelope_correlation(X = playback_est, method = 2, ssmooth = 200)
print("using method 2 and ssmooth = 200,  no pb")
envelope_correlation(X = playback_est, method = 2, ssmooth = 200, pb = FALSE)
print("all is good!")
}
FUN <- "blur_ratio"
#run function
source(file.path("~/Dropbox/baRulho/R", paste0(FUN, ".R")))
#open in rstudio
##open.fun(fun = FUN)
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
{
print("output est")
a <- blur_ratio(X = playback_est)
print("output data frame")
blur_ratio(X = playback_est, output = "data.frame")
print("using method 1 and msmooth")
b2 <- envelope_correlation(X = playback_est, msmooth = c(700, 50))
print("using method 2")
a <- envelope_correlation(X = playback_est, method = 2)
print("using method 2 and ssmooth = 200")
b <- envelope_correlation(X = playback_est, method = 2, ssmooth = 200)
print("using method 2 and ssmooth = 200,  no pb")
envelope_correlation(X = playback_est, method = 2, ssmooth = 200, pb = FALSE)
print("all is good!")
}
FUN <- "spectrum_correlation"
#run function
source(file.path("~/Dropbox/baRulho/R", paste0(FUN, ".R")))
#open in rstudio
##open.fun(fun = FUN)
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
{
print("using method 1")
a <- spectrum_correlation(X = playback_est)
print("using method 1 and ssmooth = 200")
b <- spectrum_correlation(X = playback_est)
print("using method 1 and msmooth")
b2 <- spectrum_correlation(X = playback_est)
print("using method 2")
a <- spectrum_correlation(X = playback_est, method = 2)
print("using method 2 and ssmooth = 200")
b <- spectrum_correlation(X = playback_est, method = 2)
print("using method 2 and ssmooth = 200,  no pb")
spectrum_correlation(X = playback_est, method = 2, pb = FALSE)
print("all is good!")
}
source('~/Dropbox/baRulho/R/spectrum_correlation.R')
FUN <- "spectrum_correlation"
#run function
source(file.path("~/Dropbox/baRulho/R", paste0(FUN, ".R")))
#open in rstudio
##open.fun(fun = FUN)
# remove objects but no functions
rm(list = setdiff(ls(), c(lsf.str(), "FUN")))
load("./data/playback_est.rda")
# to troubleshoot internally
for(i in run.def.args(FUN)) try(eval(parse(text = i)), silent = T)
rm(i)
#tests
{
print("using method 1")
a <- spectrum_correlation(X = playback_est)
print("using method 1 and ssmooth = 200")
b <- spectrum_correlation(X = playback_est)
print("using method 1 and msmooth")
b2 <- spectrum_correlation(X = playback_est)
print("using method 2")
a <- spectrum_correlation(X = playback_est, method = 2)
print("using method 2 and ssmooth = 200")
b <- spectrum_correlation(X = playback_est, method = 2)
print("using method 2 and ssmooth = 200,  no pb")
spectrum_correlation(X = playback_est, method = 2, pb = FALSE)
print("all is good!")
}
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/baRulho", document = TRUE, run_dont_test = FALSE)
# check spelling
devtools::spell_check("/home/m/Dropbox/baRulho")
x <- c("RColorBrewer", "devtools", "seewave", "warbleR", "monitoR", "pkgdown", "ape", "baRulho", "spelling")
aa <- lapply(x, function(y) {
if(!y %in% installed.packages()[,"Package"])  {if(!y %in% c("warbleR", "Rraven", "baRluho", "NatureSounds")) install.packages(y) else devtools::install_github(paste0("maRce10/", y))
}
try(require(y, character.only = T), silent = T)
}
)
# check spelling
devtools::spell_check("/home/m/Dropbox/baRulho")
unlink(list.files(pattern = "baRulho\\.pdf", path = "/home/m/Dropbox/baRulho/"))
# only build manual
setwd("/home/m/Dropbox/baRulho")
system("R CMD Rd2pdf /home/m/Dropbox/baRulho")
#delete NAMESPACE file
unlink("/home/m/Dropbox/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/baRulho")
devtools::document("/home/m/Dropbox/baRulho")
# only build manual
setwd("/home/m/Dropbox/baRulho")
system("R CMD Rd2pdf /home/m/Dropbox/baRulho")
unlink(list.files(pattern = "baRulho\\.pdf", path = "/home/m/Dropbox/baRulho/"))
# only build manual
setwd("/home/m/Dropbox/baRulho")
system("R CMD Rd2pdf /home/m/Dropbox/baRulho")
#built site
pkgdown::build_site(pkg = "~/Dropbox/baRulho")
system('git commit -m  "added spectrum_correlation()"')
#sent to github
system("git add .")
system('git commit -m  "added spectrum_correlation()"')
#sent to github
system("git add .")
system('git commit -m  "added spectrum_correlation()"')
sys::exec_wait("ssh-add")
sys::exec_wait("ssh-add")
setwd("~/Dropbox/baRulho/")
sys::exec_wait("ssh-add")
#sent to github
system("git add .")
system('git commit -m  "added spectrum_correlation()"')
setwd("~/Dropbox/baRulho")
#sent to github
system("git add .")
system('git commit -m  "added spectrum_correlation()"')
rs_path <- Sys.getenv('RS_RPOSTBACK_PATH')
git_askpass <- Sys.getenv('GIT_ASKPASS')
if(nchar(rs_path) && !nchar(Sys.which(git_askpass))){
PATH <- Sys.getenv("PATH")
rs_path <- unique(c(rs_path, sub("rpostback", 'postback', rs_path)))
Sys.setenv(PATH = paste(c(PATH, rs_path), collapse = .Platform$path.sep))
}
