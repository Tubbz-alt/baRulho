for (i in complt.sf)
compare.matrix[compare.matrix == i] <- paste(i, "whole.file", sep = "-")
# set new matrices to allow changes down stream
spc.cmbs.org <- spc.cmbs <- compare.matrix
}
}
X
wvdr
wvdr[x, ]
x,
x
X = sls
compare.matrix = comp_mat
#if X is not a data frame
if (!any(is.data.frame(X), is_selection_table(X), is_extended_selection_table(X))) stop("X is not of a class 'data.frame', 'selection_table' or 'extended_selection_table'")
# if is extended all should have the same sampling rate
if (is_extended_selection_table(X) & length(unique(attr(X, "check.results")$sample.rate)) > 1) stop("all wave objects in the extended selection table must have the same sampling rate (they can be homogenized using resample_est())")
#if there are NAs in start or end stop
if (any(is.na(c(X$end, X$start)))) stop("NAs found in start and/or end")
#stop if only 1 selection
if (nrow(X) == 1) stop("you need more than one selection to do cross-correlation")
# bp needed when no bottom and top freq
if (bp[1] == "pairwise.freq.range" & is.null(X$bottom.freq))  stop("'bp' must be supplied when no frequency range columns are found in 'X' (bottom.freq & top.freq)")
# stop if no bp
if(is.null(bp[1])) stop("'bp' must be supplied")
# dens deprecated
if (!is.null(dens))  write(file = "", x = "'dens' has been deprecated and will be ignored")
# dens deprecated
if (!is.null(cor.mat))  write(file = "", x = "'dens' has been deprecated and will be ignored")
#check output
if (!any(output %in% c("cor.mat", "list"))) stop("'output' must be either 'cor.mat' or 'list'")
#if wl is not vector or length!=1 stop
if (!is.numeric(wl)) stop("'wl' must be a numeric vector of length 1") else {
if (!is.vector(wl)) stop("'wl' must be a numeric vector of length 1") else{
if (!length(wl) == 1) stop("'wl' must be a numeric vector of length 1")}}
#if ovlp is not vector or length!=1 stop
if (!is.numeric(ovlp)) stop("'ovlp' must be a numeric vector of length 1") else {
if (!is.vector(ovlp)) stop("'ovlp' must be a numeric vector of length 1") else{
if (!length(ovlp) == 1) stop("'ovlp' must be a numeric vector of length 1")}}
if (!is_extended_selection_table(X)){
#return warning if not all sound files were found
fs <- list.files(path = path, pattern = "\\.wav$", ignore.case = TRUE)
if (length(unique(X$sound.files[(X$sound.files %in% fs)])) != length(unique(X$sound.files)))
write(file = "", x = paste(length(unique(X$sound.files))-length(unique(X$sound.files[(X$sound.files %in% fs)])),
".wav file(s) not found"))
#count number of sound files in working directory and if 0 stop
d <- which(X$sound.files %in% fs)
if (length(d) == 0){
stop("The .wav files are not in the working directory")
}  else {
X <- X[d, ]
}
}
# If parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
# check sampling rate is the same for all selections if not a selection table
if (is_extended_selection_table(X) & length(unique(attr(X, "check.results")$sample.rate)) > 1) stop("sampling rate must be the same for all selections")
# add selection id column to X
X$selection.id <- paste(X$sound.files, X$selec, sep = "-")
X
# keep only selections in supplied compare.matrix to improve performance
if (!is.null(compare.matrix))
X <- X[X$selection.id %in% unique(c(compare.matrix)), , drop = FALSE]
X
# if some are complete sound files
complt.sf <- setdiff(c(compare.matrix), X$selection.id)
complt.sf
# get duration of files
wvdr <- wav_dur(files = complt.sf, path = path)
wvdr
# put it in a data frame
names(wvdr)[2] <- "end"
wvdr$start <- 0
wvdr$selec <- "whole.file"
wvdr$selection.id <- paste(wvdr$sound.files, wvdr$selec, sep = "-")
out <- lapply(1:nrow(wvdr), function(x) {
# get selection that are compared against each complete sound file
sls <- setdiff(c(compare.matrix[compare.matrix[, 1] %in% wvdr$sound.files[x] | compare.matrix[, 2] %in% wvdr$sound.files[x], ]), wvdr$sound.files[x])
# get freq range as min bottom and max top of all selections to be compared against a given sound file
# channel is also the lowest
suppressWarnings(df <- data.frame(
wvdr[x, ],
channel = min(X$channel[X$selection.id %in% sls]),
bottom.freq = min(X$bottom.freq[X$selection.id %in% sls]),
top.freq = max(X$top.freq[X$selection.id %in% sls])
))
return(df)
})
wvdr <- do.call(rbind, out)
wvdr
#get intersect of column names
int.nms <- intersect(names(X), names(wvdr))
int.nms
X[, int.nms]
rbind(X[, int.nms, drop = FALSE], wvdr[, int.nms, drop = FALSE])
rbind(X[, int.nms, drop = FALSE], wvdr[, int.nms])
wvdr
wvdr[, int.nms]
X[, int.nms, drop = FALSE]
rbind(X[, int.nms, drop = FALSE], wvdr[, int.nms])
rbind(as.data.frame(X)[, int.nms, drop = FALSE], wvdr[, int.nms])
wvdr
wvdr[, int.nms]
source('~/Dropbox/R package testing/warbleR/warbleR/R/xcorr.R')
sls <- selection_table(whole.recs = TRUE, path = td, extended = F, confirm.extended = F)
sls$bottom.freq <- 3.475
sls$top.freq <- 7.15
# create a matrix that contains the selection/files to be cross-correlated
comp_mat <- matrix(c(paste(sls$sound.files[3], sls$selec[3], sep = "-"), "output.wav"),nrow = 1)
comp_mat <- rbind(comp_mat, comp_mat)
comp_mat[2, 2] <- "output (copia).wav"
# run cross correlation
xc <- xcorr(X = sls, compare.matrix = comp_mat, wl = 300, ovlp = 30, path = td, output = "list")
sls
source('~/Dropbox/R package testing/warbleR/warbleR/R/xcorr.R')
# run cross correlation
xc <- xcorr(X = sls, compare.matrix = comp_mat, wl = 300, ovlp = 30, path = td, output = "list")
X <- rbind(X[, int.nms, drop = FALSE], wvdr[, int.nms])
X
X = sls
compare.matrix = comp_mat
# bp needed when no bottom and top freq
if (bp[1] == "pairwise.freq.range" & is.null(X$bottom.freq))  stop("'bp' must be supplied when no frequency range columns are found in 'X' (bottom.freq & top.freq)")
# stop if no bp
if(is.null(bp[1])) stop("'bp' must be supplied")
# dens deprecated
if (!is.null(dens))  write(file = "", x = "'dens' has been deprecated and will be ignored")
# dens deprecated
if (!is.null(cor.mat))  write(file = "", x = "'dens' has been deprecated and will be ignored")
#check output
if (!any(output %in% c("cor.mat", "list"))) stop("'output' must be either 'cor.mat' or 'list'")
#if wl is not vector or length!=1 stop
if (!is.numeric(wl)) stop("'wl' must be a numeric vector of length 1") else {
if (!is.vector(wl)) stop("'wl' must be a numeric vector of length 1") else{
if (!length(wl) == 1) stop("'wl' must be a numeric vector of length 1")}}
#if ovlp is not vector or length!=1 stop
if (!is.numeric(ovlp)) stop("'ovlp' must be a numeric vector of length 1") else {
if (!is.vector(ovlp)) stop("'ovlp' must be a numeric vector of length 1") else{
if (!length(ovlp) == 1) stop("'ovlp' must be a numeric vector of length 1")}}
if (!is_extended_selection_table(X)){
#return warning if not all sound files were found
fs <- list.files(path = path, pattern = "\\.wav$", ignore.case = TRUE)
if (length(unique(X$sound.files[(X$sound.files %in% fs)])) != length(unique(X$sound.files)))
write(file = "", x = paste(length(unique(X$sound.files))-length(unique(X$sound.files[(X$sound.files %in% fs)])),
".wav file(s) not found"))
#count number of sound files in working directory and if 0 stop
d <- which(X$sound.files %in% fs)
if (length(d) == 0){
stop("The .wav files are not in the working directory")
}  else {
X <- X[d, ]
}
}
# If parallel is not numeric
if (!is.numeric(parallel)) stop("'parallel' must be a numeric vector of length 1")
if (any(!(parallel %% 1 == 0),parallel < 1)) stop("'parallel' should be a positive integer")
# check sampling rate is the same for all selections if not a selection table
if (is_extended_selection_table(X) & length(unique(attr(X, "check.results")$sample.rate)) > 1) stop("sampling rate must be the same for all selections")
# add selection id column to X
X$selection.id <- paste(X$sound.files, X$selec, sep = "-")
# keep only selections in supplied compare.matrix to improve performance
if (!is.null(compare.matrix))
X <- X[X$selection.id %in% unique(c(compare.matrix)), , drop = FALSE]
X
# if some are complete sound files
complt.sf <- setdiff(c(compare.matrix), X$selection.id)
# get duration of files
wvdr <- wav_dur(files = complt.sf, path = path)
# put it in a data frame
names(wvdr)[2] <- "end"
wvdr$start <- 0
wvdr$selec <- "whole.file"
wvdr$selection.id <- paste(wvdr$sound.files, wvdr$selec, sep = "-")
out <- lapply(1:nrow(wvdr), function(x) {
# get selection that are compared against each complete sound file
sls <- setdiff(c(compare.matrix[compare.matrix[, 1] %in% wvdr$sound.files[x] | compare.matrix[, 2] %in% wvdr$sound.files[x], ]), wvdr$sound.files[x])
# get freq range as min bottom and max top of all selections to be compared against a given sound file
# channel is also the lowest
suppressWarnings(df <- data.frame(
wvdr[x, ],
channel = min(X$channel[X$selection.id %in% sls]),
bottom.freq = min(X$bottom.freq[X$selection.id %in% sls]),
top.freq = max(X$top.freq[X$selection.id %in% sls])
))
return(df)
})
wvdr <- do.call(rbind, out)
wvdr
#get intersect of column names
int.nms <- intersect(names(X), names(wvdr))
rbind(X[, int.nms, drop = FALSE], wvdr[, int.nms])
X
X[, int.nms, drop = FALSE]
wvdr[, int.nms]
rbind(X[, int.nms, drop = FALSE], wvdr[, int.nms])
rbind(as.data.frame(X)[, int.nms, drop = FALSE], wvdr[, int.nms])
source('~/Dropbox/R package testing/warbleR/warbleR/R/xcorr.R')
# run cross correlation
xc <- xcorr(X = sls, compare.matrix = comp_mat, wl = 300, ovlp = 30, path = td, output = "list")
# find peaks
pks <- find_peaks(xc.output = xc, max.peak = TRUE, path = td)
pks
rm(list = ls())
#
# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))
x <- c("RColorBrewer", "devtools", "seewave", "warbleR", "monitoR", "pkgdown", "ape", "baRulho", "spelling", "ggplot2", "png", "viridis")
aa <- lapply(x, function(y) {
if(!y %in% installed.packages()[,"Package"])  {if(!y %in% c("warbleR", "Rraven", "baRulho", "NatureSounds")) install.packages(y) else devtools::install_github(paste0("maRce10/", y))
}
try(require(y, character.only = T), silent = T)
}
)
#open function in rstudio
open.fun <- function(fun) system(paste("rstudio", file.path("~/Dropbox/R package testing/baRulho/baRulho/R", paste0(fun, ".R"))))
# run default arguments in a function
run.def.args <- function(fun = NULL){
#list functions in package
rfiles <- list.files(pattern = ".R", path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", full.names = T)
# select target function file
funfile <- rfiles[gsub(".R", "", basename(rfiles)) == fun]
x <- readLines(funfile, warn = F)
st <- grep('@usage', x, fixed = T)
en <- grep('@param', x, fixed = T)[1]
x <- paste(x[st:(en-1)], collapse = " ")
x <- gsub("usage|\\@|\\#\\'", "", x)
b <- gregexpr(pattern ='\\(|\\)',x)[1][[1]]
x <- substr(x, start = b[1] + 1, stop = b[length(b)] - 1)
spltx <- strsplit(x, "\\,")[[1]]
sl <- vector()
y = 1
while(y <= length(spltx))
{
w <- spltx[y]
z <- 1
if(grepl('\\(', spltx[y]))
{z  <- 0
while(!grepl('\\)', w))
{
z <- z+ 1
w <- paste(w, ",", spltx[y + z], collapse = "")
}
z <- z + 1
}
y = y + z
sl[length(sl) + 1] <- w
}
sl <- sl[sl != "X"]
return(sl)
}
# run it like this:
# for(i in run.def.args("dfts")) try(eval(parse(text = i)), silent = T)
# remove sound files and or image files
rm.sf <- function() unlink(list.files(path = tempdir(), pattern = "\\.wav$", ignore.case = T, full.names = TRUE))
rm.sf.img <- function(mp3 = TRUE) {if(mp3)
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.mp3$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE)) else
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE))}
rm.img <- function() unlink(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$|\\.pdf$", ignore.case = T, full.names = TRUE))
#open latest image
last.img <- function() system(paste("eog", list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)))]
))
#open pdf
last.pdf <- function() system(paste("xdg-open", list.files(path = tempdir(), pattern = "\\.pdf$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.pdf", ignore.case = T, full.names = TRUE)))]
))
#find text in functions
find.text <- function(pattern, fun.only = FALSE, path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", ignore.case = T)
{
rfiles <- list.files(pattern = "\\.R$|\\.Rmd$", path = path, full.names = T, all.files = T)
#check where a word is found in each function an return the name of function where it was found and the time
res <- NULL
w <- 1
for(f in rfiles){
x <- readLines(f)
y <- grep(pattern, x, fixed = T, value = T, ignore.case = ignore.case)
if(length(y)>0 & !fun.only) {
print(gsub(pattern = "\\.R", "", (basename(f))))
for(i in y) print(i)
}
if(length(y)>0 & fun.only) res[w] <- gsub(pattern = "\\.R", "", (basename(f)))
# options(nwarnings = 0)
w = w + 1
}
if(fun.only)
{res <- res[!is.na(res)]
return(res)}
}
#replace text
repl.text <- function(pattern, repl, path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", ignore.case = T){
rfiles <- list.files(pattern = "\\.R$|\\.Rmd", path = path, full.names = T, all.files = T)
for(f in rfiles){
#find and replace
x <- readLines(f)
y <- gsub(pattern, repl, x, fixed = T, ignore.case = ignore.case)
cat(y, file=f, sep="\n")
#reread
x <- readLines(f)
w <- grep(repl, x, fixed = T, value = T, ignore.case = T)
if(length(w)>0) {
print(f)
for(i in w) print(i)
}
}
}
#find functions with specific arguments
find.arg <- function(arg1, arg2 = NULL){
rfiles <- list.files(pattern = "\\.R$", path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", full.names = T, all.files = T)
funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#big data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
# run all fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
run.all()
#delete NAMESPACE file
unlink("/home/m/Dropbox/R package testing/baRulho/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/R package testing/baRulho/baRulho")
devtools::document("/home/m/Dropbox/R package testing/baRulho/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/R package testing/baRulho/baRulho", document = TRUE, run_dont_test = FALSE)
rm(list = ls())
#
# unload all non-based packages
out <- sapply(paste('package:', names(sessionInfo()$otherPkgs), sep = ""), function(x) try(detach(x, unload = FALSE, character.only = TRUE), silent = T))
x <- c("RColorBrewer", "devtools", "seewave", "warbleR", "monitoR", "pkgdown", "ape", "baRulho", "spelling", "ggplot2", "png", "viridis")
aa <- lapply(x, function(y) {
if(!y %in% installed.packages()[,"Package"])  {if(!y %in% c("warbleR", "Rraven", "baRulho", "NatureSounds")) install.packages(y) else devtools::install_github(paste0("maRce10/", y))
}
try(require(y, character.only = T), silent = T)
}
)
#open function in rstudio
open.fun <- function(fun) system(paste("rstudio", file.path("~/Dropbox/R package testing/baRulho/baRulho/R", paste0(fun, ".R"))))
# run default arguments in a function
run.def.args <- function(fun = NULL){
#list functions in package
rfiles <- list.files(pattern = ".R", path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", full.names = T)
# select target function file
funfile <- rfiles[gsub(".R", "", basename(rfiles)) == fun]
x <- readLines(funfile, warn = F)
st <- grep('@usage', x, fixed = T)
en <- grep('@param', x, fixed = T)[1]
x <- paste(x[st:(en-1)], collapse = " ")
x <- gsub("usage|\\@|\\#\\'", "", x)
b <- gregexpr(pattern ='\\(|\\)',x)[1][[1]]
x <- substr(x, start = b[1] + 1, stop = b[length(b)] - 1)
spltx <- strsplit(x, "\\,")[[1]]
sl <- vector()
y = 1
while(y <= length(spltx))
{
w <- spltx[y]
z <- 1
if(grepl('\\(', spltx[y]))
{z  <- 0
while(!grepl('\\)', w))
{
z <- z+ 1
w <- paste(w, ",", spltx[y + z], collapse = "")
}
z <- z + 1
}
y = y + z
sl[length(sl) + 1] <- w
}
sl <- sl[sl != "X"]
return(sl)
}
# run it like this:
# for(i in run.def.args("dfts")) try(eval(parse(text = i)), silent = T)
# remove sound files and or image files
rm.sf <- function() unlink(list.files(path = tempdir(), pattern = "\\.wav$", ignore.case = T, full.names = TRUE))
rm.sf.img <- function(mp3 = TRUE) {if(mp3)
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.mp3$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE)) else
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$", ignore.case = T, full.names = TRUE))}
rm.img <- function() unlink(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$|\\.png$|\\.pdf$", ignore.case = T, full.names = TRUE))
#open latest image
last.img <- function() system(paste("eog", list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.jpg$", ignore.case = T, full.names = TRUE)))]
))
#open pdf
last.pdf <- function() system(paste("xdg-open", list.files(path = tempdir(), pattern = "\\.pdf$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.pdf", ignore.case = T, full.names = TRUE)))]
))
#find text in functions
find.text <- function(pattern, fun.only = FALSE, path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", ignore.case = T)
{
rfiles <- list.files(pattern = "\\.R$|\\.Rmd$", path = path, full.names = T, all.files = T)
#check where a word is found in each function an return the name of function where it was found and the time
res <- NULL
w <- 1
for(f in rfiles){
x <- readLines(f)
y <- grep(pattern, x, fixed = T, value = T, ignore.case = ignore.case)
if(length(y)>0 & !fun.only) {
print(gsub(pattern = "\\.R", "", (basename(f))))
for(i in y) print(i)
}
if(length(y)>0 & fun.only) res[w] <- gsub(pattern = "\\.R", "", (basename(f)))
# options(nwarnings = 0)
w = w + 1
}
if(fun.only)
{res <- res[!is.na(res)]
return(res)}
}
#replace text
repl.text <- function(pattern, repl, path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", ignore.case = T){
rfiles <- list.files(pattern = "\\.R$|\\.Rmd", path = path, full.names = T, all.files = T)
for(f in rfiles){
#find and replace
x <- readLines(f)
y <- gsub(pattern, repl, x, fixed = T, ignore.case = ignore.case)
cat(y, file=f, sep="\n")
#reread
x <- readLines(f)
w <- grep(repl, x, fixed = T, value = T, ignore.case = T)
if(length(w)>0) {
print(f)
for(i in w) print(i)
}
}
}
#find functions with specific arguments
find.arg <- function(arg1, arg2 = NULL){
rfiles <- list.files(pattern = "\\.R$", path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", full.names = T, all.files = T)
funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#big data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
# run all fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "/home/m/Dropbox/R package testing/baRulho/baRulho/R", full.names = T, all.files = T), function(x) try(source(x), silent = T)))
run.all()
#delete NAMESPACE file
unlink("/home/m/Dropbox/R package testing/baRulho/baRulho/NAMESPACE")
#run document twice
devtools::document("/home/m/Dropbox/R package testing/baRulho/baRulho")
devtools::document("/home/m/Dropbox/R package testing/baRulho/baRulho")
#check with devtools
devtools::check("/home/m/Dropbox/R package testing/baRulho/baRulho", document = TRUE, run_dont_test = FALSE)
devtools::build()
# build tar.gz package file
setwd("~/Dropbox/R package testing/baRulho/baRulho/")
devtools::build()
devtools::build()
