---
title: <center>"Acoustic space function"</center>
editor_options: 
  chunk_output_type: console
date: <center>`r format(Sys.Date(), "%d-%m-%Y")`</center>
output:
  html_document:
    theme: cerulean
    code_folding: show
---

This function calculates the acoustic space area for different individuals with varying repertoire size. The function takes the following arguments:

  - X: the proximity matrix
  - labels: the element type ID for each row in X
  - n.lements: is the different sizes of the repertoires to be simulated (number of elements). Default is `seq(5, 40, 5)` which means that there will be 8 repertoire sizes = 5, 10, 15, 20, 25, 30, 35 and 40.
  - cl: number of cores for using parallelization (if cl > 1). Might not work in windows.
  - kernel: determines if kernel density is used (but its not working great with few elements per song). Default is FALSE which means than the minimum convex polygon area is used instead.
  - rarefaction: wether to rarefact data for kernel area estimation
  - pb: progress bar
  
The function randomizes the input data so each run is a different simulation. The 1000 simulated elements (100 element types each one with 10 copies) are distributed among the the simulated individuals so most elements are used on each iteration (but the bigger the repertoire sizes the smaller the number of individuals). The output is a data frame with the repertoire size and acoustic space area for the simulated individuals (# of rows = # individuals). It also includes de stress for the multidimensional scaling (`isoMDS()` function, same value for all rows in a simulation):

```{r function, warning=FALSE, message = FALSE}

# need to load these packages first
library(MASS)  
library(adehabitatHR)  
library(pbapply)  

acoustic_spaces <- function(X, labels, n.elements = seq(5, 40, 5), cl = 1, kernel = FALSE, rarefaction = FALSE, pb = TRUE) {
  
  # reset progress bar when exiting
  on.exit(pbapply::pboptions(type = .Options$pboptions$type))
  
  # set progress bar
  pbapply::pboptions(type = ifelse(pb, "timer", "none"))
  
  # convert to distance
  dst_mt <- sqrt(1- X)
  
  # shuflle data position
  shff <- sample(1:nrow(dst_mt))
  dst_mt <- dst_mt[shff, shff] 
  labels <- labels[shff]
  
  # mds for 2 dimensions
  mds <- isoMDS(dst_mt, y = cmdscale(dst_mt, k = 2), k = 2, maxit = 5, trace = FALSE, tol = 1e-3, p = 2)
   
  # repertoires
  rps <- rep(n.elements, 10000)
  cs <- cumsum(rps)
  rps <- rps[cs < nrow(X)]
  
  rps <- sort(rps, decreasing = TRUE)
  
  df <- data.frame(labels, id = NA, mds$points)
  
  df$row <- 1:nrow(df)
    
  for(i in 1:length(rps)){

    # number of element types for each individual
    n <- rps[i]
    
    # element replicates that are available
    to.fill <- df$row[is.na(df$id)]
    df2 <- df[df$row %in% to.fill, ]
    to.fill <- df2$row[!duplicated(df2$labels)]

    # select the ones needed for this individual
    to.fill <- to.fill[1:n]  
  
    # add id of individual to data frame
    df$id[df$row %in% to.fill] <- i     
    }  

  # put indiv id, element label and MDS vectors together
  Y <- data.frame(id = df$id, labels, X1 = df$X1, X2 = df$X2)
  
  # remove not assigned rows
  Y <- Y[!is.na(Y$id), ]
  
  # if kernel area was selected
  if (kernel){
  raref_fun <- function(min.n, W) {
    Z <- W[sample(1:nrow(W), min.n), ]
    coordinates(Z) <-  ~ X1 + X2
    
    kernel.area(kernelUD(Z, extent = 1.5), percent = 95)[[1]]
    
  }
  
  # calculate acoustic area for each individual 
   krnl.area <- pblapply(unique(Y$id), cl = cl, function(y) {
    
  # subset for each individual 
  W <- Y[Y$id == y, c("X1", "X2")]
  
  if (rarefaction)
  ka <- replicate(30, raref_fun(min.n = min(n.elements), W)) else
  ka <- raref_fun(min.n = min(n.elements), W)

  return(data.frame(id = y, repertoire = nrow(W), area = mean(ka), stress = mds$stress))

  })
   
   acous.area <- do.call(rbind, krnl.area)
  } else  { # else use minimum convex polygon
    mcp.area <- pblapply(unique(Y$id), cl = cl, function(y) {
    
    # subset for each individual 
    W <- Y[Y$id == y, c("X1", "X2")]
    coordinates(W) <-  ~ X1 + X2
    
    return(data.frame(id = y, repertoire = nrow(W@coords), area = mcp(xy = W)$area, stress = mds$stress))
      })
    acous.area <- do.call(rbind, mcp.area)
    }
 
  print(paste(nrow(acous.area), "individuals simulated"))
     
 return(acous.area)
}

```


This is a test using the budgie simulated data (#21):

```{r}

load("~/Downloads/budgie syth data ap.trans.urf 21.rda")

dat <- read.csv("~/Downloads/transformed acoustic parms synthetic budgie 21.csv")

aps <- acoustic_spaces(X = ap.trans.urf$proximity, labels = dat$elm.type, cl = 3, pb = FALSE)

summary(reg <- lm(aps$area ~ aps$repertoire))

plot(aps$repertoire, aps$area, xlab = "Repertoire size",ylab =  "Acoustic space area", col = adjustcolor("blue", alpha.f = 0.5), pch = 20, cex = 2)

abline(reg = reg, lwd = 2)


```

If you repeat it you will get slightly different results:

```{r}

aps <- acoustic_spaces(X = ap.trans.urf$proximity, labels = dat$elm.type, cl = 3, pb = FALSE)


summary(reg <- lm(aps$area ~ aps$repertoire))

plot(aps$repertoire, aps$area, xlab = "Repertoire size",ylab =  "Acoustic space area", col = adjustcolor("blue", alpha.f = 0.5), pch = 20, cex = 2)

abline(reg = reg, lwd = 2)

```

Consider using log scale for repertoire size:

```{r}

summary(reg <- lm(aps$area ~ log(aps$repertoire)))

plot(log(aps$repertoire), aps$area, xlab = "Repertoire size",ylab =  "Acoustic space area", col = adjustcolor("blue", alpha.f = 0.5), pch = 20, cex = 2)

abline(reg = reg, lwd = 2)

```

